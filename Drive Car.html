<!DOCTYPE html>
<html>
<head><title>test</title></head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>

<style>
	body {
		overflow: hidden
	}

</style>

<body>


<script>
	var renderer, camera, controls, scene, keyboard = new KeyboardState();
	var Chariot = new THREE.Object3D();
	var speed, angle, vel, clock;
	var pos = new THREE.Vector3();
	var bar = [], barRadius = [];

	(function() {
	Math.clamp = function(val,min,max){
	return Math.min(Math.max(val,min),max);
	}})();

	init();
	animate();

	function loadCubemap() {

  var urls = [
    'texture/HW4/posx.jpg', 'texture/HW4/negx.jpg',
    'texture/HW4/posy.jpg', 'texture/HW4/negy.jpg',
    'texture/HW4/posz.jpg', 'texture/HW4/negz.jpg'
  ];
  var loader = new THREE.CubeTextureLoader();
  loader.setCrossOrigin('');
  var cubeMap = loader.load(urls);
  cubeMap.format = THREE.RGBFormat;
  return cubeMap;

}

	function isCrash(){
	var distX = Math.abs(A.position.x - Chariot.position.x-10);
	var distY = Math.abs(A.position.z - Chariot.position.z-20);

	if (distX > (10 + 20)) { return false; }
	if (distY > (20+ 20)) { return false; }

	if (distX <= (10)) { return true; }
	if (distY <= (20)) { return true; }

	var dx=distX-10;
	var dy=distY-20;
	return (dx*dx+dy*dy<=(20*20));
	}

	function makeBar(){
	var barM = new THREE.MeshBasicMaterial({
	color: 0x426ef4
	});

	barRadius[0] = 10;
	bar[0] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[0], barRadius[0], 100, 20), barM.clone());
	bar[0].position.set(30, 50, 90);
	barRadius[1] = 20;
	bar[1] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[1], barRadius[1], 50, 20), barM.clone());
	bar[1].position.set(-80, 25, 60);
	barRadius[2] = 15;
	bar[2] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[2], barRadius[2], 80, 20), barM.clone());
	bar[2].position.set(100, 40, 80);
	barRadius[3] = 18;
	bar[3] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[3], barRadius[3], 120, 20), barM.clone());
	bar[3].position.set(-160, 60, 20);
	barRadius[4] = 18;
	bar[4] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[4], barRadius[4], 75, 20), barM.clone());
	bar[4].position.set(-160, 37.5, -90);
	barRadius[5] = 25;
	bar[5] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[5], barRadius[5], 60, 20), barM.clone());
	bar[5].position.set(60, 30, -70);
	barRadius[6] = 17;
	bar[6] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[6], barRadius[6], 90, 20), barM.clone());
	bar[6].position.set(40, 45, -170);
	barRadius[7] = 17;
	bar[7] = new THREE.Mesh(new THREE.CylinderGeometry(barRadius[7], barRadius[7], 85, 20), barM.clone());
	bar[7].position.set(80, 42.5, -120);

	//scene.add(bar[0]);

	for(var key in bar){
	scene.add(bar[key]);
	}
	}

	function init() {

	renderer = new THREE.WebGLRenderer({
	antialias: true
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);

	camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(0, 150, 250); // important

	camera3rd = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);

	controls = new THREE.OrbitControls(camera, renderer.domElement);

	scene = new THREE.Scene();
	clock = new THREE.Clock();

	let axes = new THREE.AxisHelper(100);
	//scene.add(axes);

	var gridXZ = new THREE.GridHelper(400, 40, 'red', 'white');
	//scene.add(gridXZ);
	window.addEventListener('resize', onWindowResize, false);

	//柏油路
	var loader = new THREE.TextureLoader();
	loader.setCrossOrigin ('');
	var floorTexture = loader.load('texture/HW4/road.jpg');
	var floorMaterial = new THREE.MeshBasicMaterial({
	map: floorTexture,
	side: THREE.DoubleSide
	});
	var floorGeometry = new THREE.PlaneGeometry(400, 400, 1, 1);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);

	floor.rotation.set(Math.PI / 2, 0, Math.PI / 2) ;
	scene.add(floor);

	//skyBox
  var cubeMap = loadCubemap();
  scene.background = cubeMap;

	// model
			var onProgress = function(xhr) {
				if (xhr.lengthComputable) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + '% downloaded');
				}
			};
			var onError = function(xhr) {};
			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setPath('model/');
			mtlLoader.load('car.mtl', function(materials) {
				materials.preload();
				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath('model/');
				objLoader.load('car.obj', function(object) {
				Chariot.add(unitize (object, 20));
				scene.add(Chariot);
				scene.add (new THREE.BoxHelper (Chariot));

				//////// MATERIAL ADJUSTMENT for porsche ///////////////
				// transparent window: double-side fix
				object.traverse (
					function(mesh) {
						if (mesh instanceof THREE.Mesh) {
							mesh.material.side = THREE.DoubleSide;
						}
					});
				}, onProgress, onError);
			});




	///////////////////////////

	speed = 5.0;
	angle = 0;

	makeBar();
	}


	function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function checkIntersect(rect, circle) {
	var rad2 = circle.r * circle.r;
	var max = rect.max.clone().sub(circle.c);
	var min = rect.min.clone().sub(circle.c);

	if (max.x < 0) {
	if (max.z < 0) return (max.x*max.x + max.z*max.z < rad2);
	else if (min.z > 0) return (max.x*max.x + min.z*min.z < rad2);
	else return (Math.abs(max.x) < circle.r);
	}

	else if (min.x > 0) {
	if (max.z < 0) return (min.x*min.x + max.z*max.z < rad2);
	else if (min.z > 0) return (min.x*min.x + min.z*min.z < rad2);
	else return (min.x < circle.r);
	}

	else {
	if (max.z < 0) return (Math.abs(max.z) < circle.r);
	else if (min.z > 0) return (min.z < circle.r);
	else return true;
	}
	}

	function animate() {
	keyboard.update();

	var dt = clock.getDelta();

	if ( keyboard.pressed("A") ) angle += 0.05;
	if ( keyboard.pressed("D") ) angle -= 0.05;
	if ( keyboard.pressed("W") ) speed += 0.8;
	if ( keyboard.pressed("S") ) speed -= 0.8;

	speed = Math.clamp (speed, 0.1, 100.0);
	vel = new THREE.Vector3(speed,0,0);

	vel.applyAxisAngle (new THREE.Vector3(0,1,0), angle);
	pos.add (vel.clone().multiplyScalar(dt));

	Chariot.position.copy(pos);
	Chariot.rotation.y = angle;

	/////???
	var rect = {};
	var p = Chariot.worldToLocal(Chariot.position.clone());
	rect.max = p.clone().add (new THREE.Vector3(21/2, 0, 10.76/2)); //////用個變數存起來ㄅ
	rect.min = p.clone().sub (new THREE.Vector3(21/2, 0, 10.76/2));
	for(var key in bar){
	var circ = {};
	circ.c = Chariot.worldToLocal(bar[key].position.clone());
	circ.r = barRadius[key];
	if(checkIntersect(rect, circ)){
		bar[key].material.color = new THREE.Color(0xfc2d2d);
		//break;
	}
	else
		bar[key].material.color = new THREE.Color(0x426ef4);
	}
	/////

	controls.update();
	renderer.render(scene, camera);
	requestAnimationFrame(animate);
	}


	function unitize (object, targetSize) {
	    	// find bounding box of 'object'
	    	var box3 = new THREE.Box3();
	    	box3.setFromObject (object);
	    	var size = new THREE.Vector3();
	    	size.subVectors (box3.max, box3.min);
	    	var center = new THREE.Vector3();
	    	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	    	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	    	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	    	// uniform scaling according to objSize
	    	var objSize = Math.max (size.x, size.y, size.z);
	    	var scaleSet = targetSize/objSize;
	    	var theObject =  new THREE.Object3D();
	    	theObject.add (object);
	    	object.scale.set (scaleSet, scaleSet, scaleSet);
	    	object.position.set (-center.x*scaleSet, -center.y*scaleSet + size.y/2*scaleSet, -center.z*scaleSet);
				theObject.rotation.y = Math.PI/2;
	    	return theObject;
	    }


</script>

</body>
</html>
